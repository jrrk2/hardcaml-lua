#use "topfind";;
#directory "_build";;
#require "msat";;
#require "msat.sat";;
#require "msat.tseitin";;
#print_depth 100;;

module Sat = Msat_sat
module E = Sat.Int_lit (* expressions *)
module F = Msat_tseitin.Make(E)

let example () =
begin
let solver = Sat.create () in
(* We create here two distinct atoms *)
let a = E.fresh () in (* A fresh atom is always distinct from any other atom *)
let b = E.make 1 in   (* Atoms can be created from integers *)

(* Let's create some formulas *)
let p = F.make_atom a in
let q = F.make_atom b in
let r = F.make_and [p; q] in
let s = F.make_or [F.make_not p; F.make_not q] in
let m = F.make_cnf r in
let u = F.make_cnf s in
let _  = Sat.assume solver m () in
let res = Sat.solve solver in
let _  = Sat.assume solver u () in
let res' = Sat.solve solver in
res, res'
end

open Input
open Input_rewrite_types

type ind = {wires:(string, F.t option) Hashtbl.t;
            undef:(string * ilang list, unit) Hashtbl.t;
            conn:(string * string, unit) Hashtbl.t}

let oth' = ref None
let othopt = ref None
let othkind = ref None
let othconn = ref None
let othconnlst = ref []

let idx s i = s^"["^string_of_int i^"]"
let rec value str = Char.code str.[0] + 128 * (let len = String.length str in if len > 1 then value (String.sub str 1 (len-1)) else 0)

let getw ind string' =
  match Hashtbl.find_opt ind.wires string' with
    | Some x -> x
    | None -> failwith (string'^" not declared")

let addinp idx idx' ind string' =
  match Hashtbl.find_opt ind.wires string' with
    | Some x -> print_endline (string'^" redeclared")
    | None -> Hashtbl.add ind.wires string' ( Some ( F.make_atom ( E.make (idx*1000+idx') )) )

let addff ind string' = Hashtbl.replace ind.wires string' ( Some ( F.make_atom ( E.make (value string' ))))

let addwire idx' ind string' =
  match Hashtbl.find_opt ind.wires string' with
    | Some x -> print_endline (string'^" redeclared")
    | None -> Hashtbl.add ind.wires string' None

let addfunc ind string' func =
  match Hashtbl.find_opt ind.wires string' with
    | Some None -> Hashtbl.replace ind.wires string' (Some func)
    | Some _ -> print_endline (string'^" redeclared")
    | None -> print_endline (string'^" undefined")

let addconn ind lhs' rhs' =
  match getw ind rhs' with
   | Some func' -> addfunc ind lhs' func'
   | None -> Hashtbl.replace ind.conn (lhs',rhs') ()

let conn' ind = function
  | TokConn ([TokID pin], [Sigspec90 (signal, ix)]) -> let s = idx signal ix in pin, s, getw ind s
  | TokConn ([TokID pin], [TokID (signal)]) -> pin, signal, getw ind signal
  | oth -> othconn := Some oth; failwith "conn'"

let addnxt ind data d q =
   let lhs' = "nxt$"^q in
   addwire 0 ind lhs';
   match d with
       | Some d -> addfunc ind lhs' d
       | None -> Hashtbl.replace ind.conn (lhs',data) ()

let pinmap ind conns = List.sort compare (List.map (conn' ind) conns)

let func ind kind conns = match kind, pinmap ind conns with
  | "$_AND_",("\\A", _, Some a) :: ("\\B", _, Some b) :: ("\\Y", y, None) :: [] -> addfunc ind y (F.make_and [a;b])
  | "$_NOT_",("\\A", _, Some a) :: ("\\Y", y, None) :: [] -> addfunc ind y (F.make_not a)
  | "$_SDFF_PP0_",("\\C", clk, c) :: ("\\D", data, d) :: ("\\Q", q, None) :: ("\\R", rst, r) :: [] ->
     addff ind q;
     addnxt ind data d q;
  | "$_XOR_",("\\A", _, Some a) :: ("\\B", _, Some b) :: ("\\Y", y, None) :: [] -> addfunc ind y (F.make_xor a b)
  | oth,_ -> Hashtbl.replace ind.undef (kind,conns) ()

let rec cnv_ilang ind = function
| Autoidx_stmt26(int') -> ()
| Attr_stmt(string,ilang_lst') -> ()
| Module12(string,ilang_lst') -> print_endline string; List.iter (cnv_ilang ind) ilang_lst'
| Wire_stmt(options,string') -> let wid = ref None and fn = ref addwire in List.iter (function
    | Wire_optionswidth n -> wid := Some n;
    | Wire_optionsinput n -> fn := addinp n;
    | Wire_optionsoutput _ -> ()
    | oth -> othopt := Some oth; failwith "options") options;
    (match !wid with
      | None -> !fn 0 ind string'
      | Some n -> for i = 0 to n-1 do !fn (i+1) ind (idx string' i) done); ()
| Cell_stmt(kind,inst,params,conns) -> func ind kind conns; ()
| Conn_stmt96 ([Sigspecrange (lhs, hi, lo)], [Sigspecrange (rhs, hi', lo')]) ->
for i = 0 to hi-lo do
  let lhs' = idx lhs (hi-i) in
  let rhs' = idx rhs (hi'-i) in
  addconn ind lhs' rhs'
done
| Conn_stmt96 ([Sigspec90 (lhs, ix)], [Sigspec90 (rhs, ix')]) ->
  let lhs' = idx lhs ix in
  let rhs' = idx rhs ix' in
  addconn ind lhs' rhs'
(*
| Conn_stmt96([lft],[rght]) -> ()
| Assign_stmt67(ilang_lst,ilang_lst') -> ()
| Attr_list56(ilang_lst,ilang_lst') -> ()
| Case_body63(ilang_lst,ilang_lst') -> ()
| Case_body64(ilang_lst,ilang_lst') -> ()
| Case_body65(ilang_lst,ilang_lst') -> ()
| Cell_bodyconnect(ilang_lst,string,ilang_lst',ilang_lst2) -> ()
| Cell_bodyparam(ilang_lst,string,ilang_lst',ilang_lst2) -> ()
| Cell_bodypreal(ilang_lst,string,ilang_lst',ilang_lst2) -> ()
| Cell_bodypsigned(ilang_lst,string,ilang_lst',ilang_lst2) -> ()
| Compare_list61(ilang_lst,ilang_lst') -> ()
| Design6(ilang_lst,ilang_lst') -> ()
| Design7(ilang_lst,ilang_lst') -> ()
| Design8(ilang_lst,ilang_lst') -> ()
| Input2(ilang_lst,ilang_lst') -> ()
| Memory_optionsoffset(int') -> ()
| Memory_optionssize(int') -> ()
| Memory_optionswidth(int') -> ()
| Memory_stmt39(ilang_lst,string') -> ()
| Module_body13(ilang_lst,ilang_lst') -> ()
| Param_defval_stmt24(string,ilang_lst') -> ()
| Param_stmt23(string,ilang_lst') -> ()
| Proc_stmt(string,ilang_lst,ilang_lst',ilang_lst2) -> ()
| Signed -> ()
| Sigspec90(string, int') -> ()
| Sigspec92(ilang_lst') -> ()
| Sigspec_list_reversed93(ilang_lst,ilang_lst') -> ()
| Sigspecrange(string,int,int') -> ()
| Switch_bodycase(ilang_lst,ilang_lst',ilang_lst2) -> ()
| Switch_stmt(ilang_lst,ilang_lst',ilang_lst2,ilang_lst3) -> ()
| Sync_list69(ilang_lst',ilang_lst2,ilang_lst3,ilang_lst4) -> ()
| Sync_listalways(ilang_lst',ilang_lst2) -> ()
| Sync_listglobal(ilang_lst',ilang_lst2) -> ()
| Sync_listinit(ilang_lst',ilang_lst2) -> ()
| Update_list82(ilang_lst',ilang_lst2) -> ()
| Update_listmemwr(string,ilang_lst2,ilang_lst3,ilang_lst4,ilang_lst5) -> ()
| Upto -> ()
| Wire_optionsinout(int) -> ()
| Wire_optionsinput(int) -> ()
| Wire_optionsinvalid -> ()
| Wire_optionsoffset(int') -> ()
| Wire_optionsoutput(int') -> ()
| Wire_optionswidth(int') -> ()
| TokCase(ilang_lst,ilang_lst') -> ()
| TokConn(ilang_lst,ilang_lst') -> ()
| TokParam(ilang_lst,ilang_lst') -> ()
| TokUpdate(ilang_lst,ilang_lst') -> ()
| TokInt(int) -> ()
| TokID(string) -> ()
| TokVal(string) -> ()
| TokStr(string) -> ()
| TokPos -> ()
| TokNeg -> ()
| TokEdge -> ()
*)
| oth -> oth' := Some oth; failwith "cnv_ilst"

and cnv_ilst ind lst = List.iter (cnv_ilang ind) lst

let pp q =
  let buf' = Buffer.create 1000 in
  let buf = Format.formatter_of_buffer buf' in
  List.iter (fun itm ->
    List.iter (fun itm -> E.pp buf itm; Format.pp_print_space buf ()) itm;
    Format.pp_print_flush buf ();
    ) (F.make_cnf q);
  print_endline (Buffer.contents buf')

let fpp q =
  let buf' = Buffer.create 1000 in
  let buf = Format.formatter_of_buffer buf' in
  F.pp buf q;
  Format.pp_print_flush buf ();
  print_endline (Buffer.contents buf')

let ep q =
    let m = F.make_cnf q in
    let solver = Sat.create () in
    Sat.assume solver m ();
    Sat.solve solver

let cnv_sat arg =
  let ch = Hashtbl.create 255 in
  let ch' = Hashtbl.create 255 in
  let ch'' = Hashtbl.create 255 in
  let wh = Hashtbl.create 255 in
  let uh = Hashtbl.create 255 in
  let uh' = Hashtbl.create 255 in
  let uh'' = Hashtbl.create 255 in
  cnv_ilst {wires=wh;undef=uh;conn=ch} arg;
  Hashtbl.iter (fun (kind,conns) () -> func {wires=wh;undef=uh';conn=ch} kind conns) uh;
  Hashtbl.iter (fun (lhs',rhs') () -> addconn {wires=wh;undef=uh';conn=ch'} lhs' rhs') ch;
  Hashtbl.iter (fun (kind,conns) () -> func {wires=wh;undef=uh'';conn=ch} kind conns) uh';
  Hashtbl.iter (fun (lhs',rhs') () -> addconn {wires=wh;undef=uh';conn=ch''} lhs' rhs') ch';
  let ulst=ref [] in
  Hashtbl.iter (fun (kind,conns) () -> ulst := (kind,pinmap {wires=wh;undef=uh';conn=ch} conns) :: !ulst) uh'';
  let clst=ref [] in
  Hashtbl.iter (fun k x -> clst := (k,x) :: !clst) ch'';
  let hlst=ref [] in
  Hashtbl.iter (fun k -> function Some x -> hlst := (k,x) :: !hlst | None -> failwith ("hlst: "^k)) wh;
  !clst, !hlst, !ulst

let compare golden proc =
    let clst, hlst, ulst = cnv_sat golden in
    let q = Array.init 3 (fun ix -> List.assoc (idx "nxt$\\q" ix) hlst) in
    let clk = List.assoc "\\clk" hlst in
    let clst', hlst', ulst' = cnv_sat !proc in
    let q' = Array.init 3 (fun ix -> List.assoc (idx "nxt$\\q" ix) hlst') in
    let clk' = List.assoc "\\clk" hlst' in
    let mitre = F.make_or (List.map2 (F.make_xor) (Array.to_list q) (Array.to_list q')) in
    let res = ep mitre in
    match res with
      | Sat.Sat _ -> print_endline "SATISFIABLE"
      | Sat.Unsat _ -> print_endline "UNSATISFIABLE"
