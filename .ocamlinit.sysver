
(*
open Output
open Template
open Output_parser

let _ = parse "V3ParseBison.output";;
let (t,g) = List.hd !tg';;
let mungelst = ref [];;
Hashtbl.iter (fun k x -> mungelst := (k,x) :: !mungelst) mungeh;;
let fd = open_out "mungelst.ml" in
List.iter ( fun (k,x) ->
	  Printf.fprintf fd "    %s, \"%s\";\n" k x
	  ) (List.sort compare !mungelst);
close_out fd
;;
*)

#directory "/Users/jonathan/.opam/default/lib/hardcaml"
#directory "/Users/jonathan/.opam/default/lib/hardcaml_waveterm"
#directory "/Users/jonathan/.opam/default/lib"

open Source_text_rewrite_types
open Source_text_rewrite
open Source_text_lex
open Source_text
open Vxml_types
open Dump_rtlil
open Matchmly
open Vxml
;;

let v = "timer.v";;
let v = "interface_test.sv";;
let v = "wrapper.sv";;
let v = "loop.v";;
let v = "picorv32_ref.v";;
let v = "process.v";;
let v = "preprocess.sv";;
let v = "blocking.v";;
let v = "prec.sv";;
let v = "casetest.sv";;
let v = "apb_uart.vsyn";;
let v = "insider.sv";;
let v = "ariane_preproc.sv";;
let v = "apb_uart.sv";;
let v = "examples/add.v";;
let v = "examples/count.v";;

(*
let x = rw (parse v);;
*)

(* *)
let (modlst,x,p,p') = rewrite_rtlil v;;
(* *)

(*
let u = match List.assoc "add" !(Matchmly.modules) with Modul(_, _, ports, lst) -> lst;;
let v = List.filter (function DeclReg _ -> false| _ -> true) u;;


Let _ = Hashtbl.iter (fun k x -> let fd = open_out (k^".dump") in dump fd x; close_out fd) modules;;

let y = unroll {subst=Hashtbl.create 255; fn=descend} x;;

let z = Hashtbl.find modules "apb_uart";;
let Modul(entnam, parms, port_lst, body_lst) = z;;
let s, s' = List.partition (function Sentry _ -> false | DeclReg _ -> false | Asgnlst _ -> false | DeclIntf1 _ -> false | Hash _ -> false | _ -> true) body_lst;;
let h = List.filter (function Hash _ -> true | _ -> false) s';;

let a x = List.nth s x;;

let b = List.filter (function DeclReg _ -> false | Asgnlst _ -> true | Sentry _ -> false | _ -> false) body_lst;;

let rwmods = Hashtbl.create 255;;

let scanp = 
  List.iter (function
    | TUPLE7 (TUPLE3 (Module, EMPTY_TOKEN, IDENTIFIER nam), arg1, arg2, arg3, arg4, arg5, arg6) -> Hashtbl.add rwmods nam (arg1, arg2, arg3, arg4, arg5, arg6)
    | _ -> failwith "scanp")

let _ = match p' with
    | TUPLE2(TLIST lst, _) -> scanp lst
    | _ -> ();;

let declhash = Hashtbl.create 255;;
let conthash = Hashtbl.create 255;;
let othdecl = ref None
let othasgn = ref None

let (arg1, arg2, arg3, arg4, arg5, arg6) = Hashtbl.find rwmods "apb_uart";;
let TLIST lst = arg4;;
let lst',lst'' = List.partition (function TUPLE5 (Assign, _, _, _, _) -> true | _ -> false) lst;;
let lst''' = List.filter (function
  | TUPLE2 (Always, _) -> false
  | TUPLE4 (IDENTIFIER _, TUPLE4(HASH, _, _, _), _, _) -> false
  | TUPLE4 (IDENTIFIER _, EMPTY_TOKEN, TLIST (TUPLE5 _ :: _), _) -> false
  | _ -> true) lst'';;
let _ = List.iter (function
  | TUPLE3 (TUPLE3 (Reg, EMPTY_TOKEN, dimlst), TLIST [TUPLE3 (IDENTIFIER lhs, EMPTY_TOKEN, EMPTY_TOKEN)], SEMICOLON) as x -> Hashtbl.replace declhash lhs x
  | TUPLE3 (TUPLE3 (EMPTY_TOKEN, TYPE_HYPHEN_IDENTIFIER typ_id, EMPTY_TOKEN), TLIST [TUPLE3 (IDENTIFIER lhs, EMPTY_TOKEN, EMPTY_TOKEN)], SEMICOLON) as x -> Hashtbl.replace declhash lhs x
  | TUPLE4 (IDENTIFIER typ_id, EMPTY_TOKEN, TLIST [TUPLE2 (IDENTIFIER lhs, EMPTY_TOKEN)], SEMICOLON) as x -> Hashtbl.replace declhash lhs x
  | TUPLE6 (Typedef, TUPLE5 (Enum, typ_decl, LBRACE, TLIST id_lst, RBRACE), IDENTIFIER typ_id, EMPTY_TOKEN, EMPTY_TOKEN, SEMICOLON) as x -> Hashtbl.replace declhash typ_id x
  | TUPLE6 (Typedef, TUPLE5 (Enum, typ_decl, LBRACE, TLIST lst, RBRACE), TYPE_HYPHEN_IDENTIFIER typ_id, EMPTY_TOKEN, EMPTY_TOKEN, SEMICOLON) as x ->  Hashtbl.replace declhash typ_id x
  | TUPLE3 (TUPLE3 (Logic, EMPTY_TOKEN, EMPTY_TOKEN), TLIST lst, SEMICOLON) as x -> List.iter (function TUPLE3 (IDENTIFIER nam, EMPTY_TOKEN, EMPTY_TOKEN) -> Hashtbl.replace declhash nam x) lst
  | TUPLE3 (TUPLE3 (EMPTY_TOKEN, TYPE_HYPHEN_IDENTIFIER typ, EMPTY_TOKEN), TLIST lst, SEMICOLON) as x -> List.iter (function
      | TUPLE3 (IDENTIFIER nam, EMPTY_TOKEN, EMPTY_TOKEN) -> Hashtbl.replace declhash nam x
      | oth -> othdecl := Some oth; failwith "Decltyp" ) lst
  | oth -> othdecl := Some oth; failwith "Decl") lst''';;

let alst' = List.filter (function
  | TUPLE2 (Always, _) -> true
  | _ -> false) lst'';;

let caselst = ref [];;

let _ = List.iter (function
  | TUPLE2 (Always,
     TUPLE2
      (TUPLE4 (AT, LPAREN, TUPLE3 (_, Or, _), RPAREN),
       TUPLE8 (EMPTY_TOKEN, If, LPAREN, _, RPAREN, TUPLE4 (Begin, TLIST lst1, End, EMPTY_TOKEN), Else, TUPLE4 (Begin, TLIST lst, _, _)))) -> ()
  | TUPLE2 (Always,
      TUPLE2 (TUPLE4 (AT, LPAREN, _, RPAREN),
        TUPLE4 (Begin,
          TLIST
           [TLIST
             [TUPLE5
               (EMPTY_TOKEN,
                TUPLE4 (Case, LPAREN, _, RPAREN),
                EMPTY_TOKEN,
                TLIST lst1,
		Endcase)]], End, EMPTY_TOKEN))) -> caselst := lst1 :: !caselst
  | oth -> othasgn := Some oth; failwith "always") alst';;

let itms = ref [];;
let itms' = ref [];;
let _ = List.iter (collapse_case itms itms') (List.rev (List.hd !caselst));;

let _ = List.iter (function
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (IDENTIFIER lhs, EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (TUPLE6 (IDENTIFIER lhs, LBRACK, hi, COLON, lo, RBRACK), EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (TUPLE4 (IDENTIFIER lhs, LBRACK, ix, RBRACK), EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | oth -> othasgn := Some oth; failwith "Assign") lst';;

let v' = List.filter (function
 | (Source_text_rewrite_types.Add _, _, _) -> false
 | ((Sub _ |Id _|Number _ | Intgr _ | Slice _ | Sel _ | Equals _ | GtEq _ | Expression (Equals _) | Expression (Or (Equals _ , Equals _))), _, _) -> false
 | (And2 _, _, _) -> true
 | _ ->false) !vlst;;

*)
