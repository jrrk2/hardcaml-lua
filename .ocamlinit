#directory "../vpiparse";;
#directory "/Users/jonathan/.opam/default/lib/base";;
#print_length 10000000;;
#print_depth 10000000;;
(*
#print_length 1000;;
#print_depth 200;;
*)
(**************************************************************************)
(*                                                                        *)
(* OCaml template Copyright (C) 2004-2010                                 *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(* Adapted to boolean logic by Jonathan Kimmitt                           *)
(*  Copyright 2016 University of Cambridge                                *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*
#use ".ocamlinit.output"
*)

(*
#use ".ocamlinit.lef"
*)

(*
#use ".ocamlinit.program"
*)

(*
#use ".ocamlinit.liberty"
*)

(*                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*
#use ".ocamlinit.output"
*)

(*
#use ".ocamlinit.lef"
*)

(*
#use ".ocamlinit.program"
*)

(*
#use ".ocamlinit.ansic"
*)

(*
#use ".ocamlinit.liberty"
*)

(*
#use ".ocamlinit.sysver"
*)

(*
#use ".ocamlinit.msat"
*)

(*
#use ".ocamlinit.hardcaml"
*)

(*
#use ".ocamlinit.pat"
*)

(*
#use ".ocamlinit.ilang"
*)

(*
let x = classify' v;;
*)

(*
#use ".ocamlinit.convert"
*)

(*
#use ".ocamlinit.crypto"
*)

(*
open Source_text_convert
open Source_text_rewrite_types
let modlst,x,p,p',status = rewrite_sat "../yosys/share/simcells.v" "convert.ml"
*)

(*
open Source_text
open Source_text_rewrite
open Source_reduced_main
open Source_text_rewrite_types
open Dump_xml
open Input_types
open Dump_types
open Input_rewrite_types
open Source_text_rewrite_types

let (modlst,x,p,p',status) = rewrite_rtlil "examples/andvec.v";;

let rtl = match !othrtl with Some (Itmlst (hd::[])) -> hd;;
let rslt = [("count", Dump_rtlil.template (ref []) rtl)];;
let (nam, rslt') = List.hd rslt in
let fd = open_out "junk.rtlil" in
let _ = List.iter (fun itm -> output_string fd (Rtlil_dump.dump_ilang "" itm)) rslt' in
close_out fd;;
let _, arg = Input_rewrite.parse "synth";;
let tmplst = cnv_sat_tree arg;;
let hardlst = cnv_sat_tree rslt;;

open Template
open Output_parser
let _ = Output.parse "verible.output"
let lst = ref [];;
Hashtbl.iter (fun k x -> lst := (k,x) :: !lst) termhash;;
let termlst' = List.sort compare (List.filter (fun (_, (t, _)) -> t) !lst);;
let found = List.assoc "TK_XZDigits" !lst;;
*)

open Base__String
open Source_text_verible_rewrite_types
open Source_text_verible_lex
open Source_text_verible
open Source_text_verible_rewrite
open Verible_pat
open Input_dump

let v = "examples/ariane_preproc.sv";;
let v = "examples/picorv32_ref.v";;
let v = "examples/count0.v";;
let p = parse_output_ast_from_file v;;
let p' = Source_text_verible_rewrite.rw p;;

let p'' = pat p';;

let othtran = ref `empty
let uitms = empty_itms []

let rec bin_to_native x = match String.length x with
| 0 -> 0
| 1 -> Char.code (x.[0]) - Char.code '0'
| n -> bin_to_native (String.sub x 0 (n-1)) * 2 + bin_to_native (String.sub x (n-1) 1)

let rec tran (itms:Input_types.itms) modnam = function
| `ml_start1 (`tlist modlst) -> List.iter (tran itms modnam) modlst 
| `module_or_interface_declaration1 (modnam', `tlist declst, `tlist bodylst) ->
    modnam := modnam';
    List.iter (tran itms modnam) declst;
    List.iter (tran itms modnam) bodylst
| `port_declaration_noattr1 (`data_type_or_implicit_basic_followed_by_id_and_dimensions_opt1
       (`data_type_primitive1 (`data_type_primitive_scalar1_reg, `decl_variable_dimension1 (hi, lo)),
        `unqualified_id1 (id, `empty))) ->
    itms.io := (id, ("", (BASDTYP, "reg", TYPRNG (tran' hi, tran' lo), []), Doutput, "wire", [])) :: !(itms.io)
| `port_declaration_noattr1 (`type_identifier_or_implicit_basic_followed_by_id_and_dimensions_opt4
       (`unqualified_id1 (id, `empty))) ->
    itms.io := (id, ("", (BASDTYP, "wire", TYPNONE, []), Dinput, "wire", [])) :: !(itms.io)
| `always_construct1 (`procedural_timing_control_statement2 (`event_control2 (`tlist
             [`event_expression_posedge (`unqualified_id1 (clk, `empty))]), body)) -> 
      itms.alwys := ("", Input_types.POSEDGE clk, tran'' body :: []) :: !(itms.alwys)
| `comma -> ()
| oth -> othtran := oth; failwith "tran"

and tran' = function
| `dec_num s -> HEX (int_of_string s)
| oth -> othtran := oth; failwith "tran'"

and tran'' = function
| `bin_based_number1 (radix, bin) -> Scanf.sscanf radix "%d'b" (fun rad -> Input_types.CNST(rad, HEX (bin_to_native bin)))
| `add_expr (lhs, rhs) -> ARITH (Aadd "", tran'' lhs :: tran'' rhs :: [])
| `unqualified_id1 (id, `empty) -> VRF (id, (BASDTYP, "wire", TYPNONE, []), [])
| `conditional_statement2 (`expression_in_parens1 cond, then_, else_) ->
  Input_types.IF ("", tran'' cond :: tran'' then_ :: tran'' else_ :: [])
| `statement_item6 (`assignment_statement_no_expr1 (rhs, lhs)) -> ASGN( false, "", tran'' lhs :: tran'' rhs :: [])
| oth -> othtran := oth; failwith "tran''"

let modnam = ref "";;
let _ = tran uitms modnam p'';;
let _ = Input_dump.dump' "junk1" ("junk1", ((), uitms));;
let rtl = Input_hardcaml.cnv (!modnam, uitms);;
let fd = open_out "rtl.v" in output_string fd rtl; close_out fd;
(*
let tree = Source_text_rewrite.parse_output_ast_from_string rtl in
othrtl := Some tree;
Input_dump.dump' "_tmp" cnvrted;
*)
