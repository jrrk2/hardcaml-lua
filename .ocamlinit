(**************************************************************************)
(*                                                                        *)
(* OCaml template Copyright (C) 2004-2010                                 *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(* Adapted to boolean logic by Jonathan Kimmitt                           *)
(*  Copyright 2016 University of Cambridge                                *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*
#use ".ocamlinit.output"
*)

(*
#use ".ocamlinit.lef"
*)

(*
#use ".ocamlinit.program"
*)

(*
#use ".ocamlinit.ansic"
*)

(*
open Output
open Template
open Output_parser

let _ = parse "V3ParseBison.output";;
let (t,g) = List.hd !tg';;
let mungelst = ref [];;
Hashtbl.iter (fun k x -> mungelst := (k,x) :: !mungelst) mungeh;;
let fd = open_out "mungelst.ml" in
List.iter ( fun (k,x) ->
	  Printf.fprintf fd "    %s, \"%s\";\n" k x
	  ) (List.sort compare !mungelst);
close_out fd
;;
*)

open Source_text_rewrite_types
open Source_text_rewrite
open Source_text_lex
open Source_text
open Dump_vhdl

let v = "timer.v";;
let v = "interface_test.sv";;
let v = "wrapper.sv";;
let v = "loop.v";;
let v = "picorv32_ref.v";;
let v = "process.v";;
let v = "preprocess.sv";;
let v = "blocking.v";;
let v = "uart.sv";;
   
let modlst,x,p,p' = rewrite v;;

(*
let _ = Hashtbl.iter (fun k x -> let fd = open_out (k^".dump") in dump fd x; close_out fd) modules;;
*)

let y = unroll {subst=Hashtbl.create 255; fn=descend} x;;

let z = Hashtbl.find modules "apb_uart";;
let Modul(entnam, port_lst, body_lst) = z;;
let s = List.filter (function Sentry _ -> true | _ -> false) body_lst;;
let h = List.hd s;;
let Sentry (Edge (Pos clk, Pos rst), blk) = h;;
let Ifelse (Equals (Id rst, Number _), BeginBlock lst2, BeginBlock lst3) = blk;;

let b = List.filter (function DeclReg _ -> false | Asgnlst _ -> true | Sentry _ -> false | _ -> false) body_lst;;

let rwmods = Hashtbl.create 255;;

let scanp = 
  List.iter (function
    | TUPLE7 (TUPLE3 (Module, EMPTY_TOKEN, IDENTIFIER nam), arg1, arg2, arg3, arg4, arg5, arg6) -> Hashtbl.add rwmods nam (arg1, arg2, arg3, arg4, arg5, arg6)
    | _ -> ())

let _ = match p' with
    | TUPLE2(TLIST lst, _) -> scanp lst
    | _ -> ();;

(*
assign   iWrite = (PSEL ==  1'b1 && PENABLE ==  1'b1) && PWRITE ==  1'b1 ?  1'b1 :   1'b0;

TUPLE3
 (TUPLE3
   (LPAREN,
    TUPLE3
     (IDENTIFIER "PSEL", EQ_EQ,
      TUPLE3
       (INTEGER_NUMBER "1'b1 ", AMPERSAND_AMPERSAND,
        TUPLE3 (IDENTIFIER "PENABLE", EQ_EQ, INTEGER_NUMBER "1'b1"))),
    RPAREN),
  AMPERSAND_AMPERSAND,
  TUPLE3
   (IDENTIFIER "PWRITE", EQ_EQ,
    TUPLE5
     (INTEGER_NUMBER "1'b1 ", QUERY, INTEGER_NUMBER "1'b1 ", COLON,
      INTEGER_NUMBER "1'b0")))
*)

let conthash = Hashtbl.create 255;;

let (arg1, arg2, arg3, arg4, arg5, arg6) = Hashtbl.find rwmods "apb_uart";;
let TLIST lst = arg4;;
let lst' = List.filter (function TUPLE5 (Assign, _, _, _, _) -> true | _ -> false) lst;;
let _ = List.iter (function
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (IDENTIFIER lhs, EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | _ -> ()) lst';;

