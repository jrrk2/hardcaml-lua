(**************************************************************************)
(*                                                                        *)
(* OCaml template Copyright (C) 2004-2010                                 *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(* Adapted to boolean logic by Jonathan Kimmitt                           *)
(*  Copyright 2016 University of Cambridge                                *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*
#use ".ocamlinit.output"
*)

(*
#use ".ocamlinit.lef"
*)

(*
#use ".ocamlinit.program"
*)

(*
#use ".ocamlinit.ansic"
*)

(*
open Output
open Template
open Output_parser
let _ = parse "V3ParseBison.output";;
let (t,g) = List.hd !tg';;
let mungelst = ref [];;
Hashtbl.iter (fun k x -> mungelst := (k,x) :: !mungelst) mungeh;;
let fd = open_out "mungelst.ml" in
List.iter ( fun (k,x) ->
	  Printf.fprintf fd "    %s, \"%s\";\n" k x
	  ) (List.sort compare !mungelst);
close_out fd
;;
*)

open Source_text_main
open Source_text_lex
open Source_text

let v = "timer.v";;
let v = "process.v";;
let v = "interface_test.sv";;
let p = parse v;;

let lst' = ref []

let rec rw = function
| CONS1 oth -> TLIST (rw oth::[])
| CONS3(lft,_,rght) -> (match rw lft with TLIST arg -> TLIST (rw rght :: arg) | _ -> failwith "CONS3")
| CONS2(lft,rght) -> (match rw lft with TLIST arg -> TLIST (rw rght :: arg) | _ -> failwith "CONS2")
| TLIST lst -> TLIST (List.map rw lst)
| TUPLE2(arg1,arg2) -> TUPLE2 (rw arg1, rw arg2)
| TUPLE3(arg1,arg2,arg3) -> TUPLE3 (rw arg1, rw arg2, rw arg3)
| TUPLE4(arg1,arg2,arg3,arg4) -> TUPLE4 (rw arg1, rw arg2, rw arg3, rw arg4)
| TUPLE5(arg1,arg2,arg3,arg4,arg5) -> TUPLE5 (rw arg1, rw arg2, rw arg3, rw arg4, rw arg5)
| TUPLE6(arg1,arg2,arg3,arg4,arg5,arg6) -> TUPLE6 (rw arg1, rw arg2, rw arg3, rw arg4, rw arg5, rw arg6)
| TUPLE7(arg1,arg2,arg3,arg4,arg5,arg6,arg7) -> TUPLE7 (rw arg1, rw arg2, rw arg3, rw arg4, rw arg5, rw arg6, rw arg7)
| TUPLE8(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8) ->
   TUPLE8(rw arg1, rw arg2, rw arg3, rw arg4, rw arg5, rw arg6, rw arg7, rw arg8)
| ((IDENTIFIER _
| INTEGER_NUMBER _
| AT|EMPTY_TOKEN|LPAREN|RPAREN|LBRACK|RBRACK|LBRACE|RBRACE|COLON|SEMICOLON|COMMA|CARET|PLUS|HYPHEN|HASH|AMPERSAND|EQUALS|LT_EQ
| Module|Always|Assign|Reg|Wire|Logic|Bit|Int|Integer|Unsigned|Output|Input|Posedge|Or|If|Else|Begin|End|DOT|Endmodule|Interface|Endinterface|Modport|Parameter|EOF_TOKEN) as oth) -> oth
| oth -> failwith ("rw fail: "^Source_text_types.getstr oth)

let missing = ref None

type rw =
  | Unknown
  | In
  | Out
  | Itmlst of rw list
  | Port of rw * string
  | Modul of string * rw list * rw list
  | Pos of string
  | Edge of rw * rw
  | Id of string
  | Intgr of int
  | Number of string
  | Sel of string * rw
  | NonBlock of string * rw
  | And of rw * rw
  | Or of rw * rw
  | Xor of rw * rw
  | Add of rw * rw
  | Sub of rw * rw
  | Ifelse of rw * rw * rw
  | Sentry of rw * rw
  | Block of rw * rw
  | Asgnlst of rw list
  | DeclReg of rw list * string list
  | DeclInt of string list
  | Dim of rw * rw
  | BeginBlock of rw list
  | Bitlst of rw list
  | Dot of string * rw
  | Concat of rw list
  | DeclIntf1 of string *rw list
  | DeclIntf2 of string *rw list
  | Hash of string * rw list * rw list
  | DeclIntf of string * rw list * rw list * rw list
  | DeclModPort of rw list
  | Repl of string * rw list
  | Slice of string * rw * rw
  | Field of string * string
  | Dot3 of string * string *string
  | Parenth of string * rw list
  | Logic of rw list * rw list
  | Param of string * rw
  | DeclLogic of rw list

let rec rw' = function
| Input -> In
| Output -> Out
| TUPLE2 (TLIST lst, EOF_TOKEN) -> Itmlst(List.rev_map rw' lst)
| TUPLE4 (Input as dir, IDENTIFIER port, EMPTY_TOKEN, EMPTY_TOKEN) -> Port(rw' dir, port)
| TUPLE5 (Output as dir, TUPLE2 (Integer, EMPTY_TOKEN), IDENTIFIER port, EMPTY_TOKEN, EMPTY_TOKEN) ->
   Port(rw' dir, port)
| TUPLE5 (Input as dir, TUPLE3 (Logic, EMPTY_TOKEN, EMPTY_TOKEN), IDENTIFIER port, EMPTY_TOKEN, EMPTY_TOKEN) ->
   Port(rw' dir, port)
| TUPLE4 (TUPLE2 ((Input|Output) as dir, Wire), IDENTIFIER port, EMPTY_TOKEN, EMPTY_TOKEN) -> 
Port (rw' dir, port)
| TUPLE2 ((Input|Output) as dir, IDENTIFIER port) -> Port(rw' dir, port)
| TUPLE7 (TUPLE3 (Module, EMPTY_TOKEN, IDENTIFIER modid), params,
   TUPLE3(LPAREN, TLIST portlst, RPAREN), SEMICOLON, TLIST itmlst, Endmodule, EMPTY_TOKEN) ->
Modul (modid, List.rev_map rw' (portlst), List.rev_map rw' (itmlst))
| TUPLE3 (TUPLE2 (Posedge, IDENTIFIER clk), (Or|COMMA), TUPLE2 (Posedge, IDENTIFIER reset)) ->
  Edge(Pos clk, Pos reset)
| TUPLE2 (Posedge, IDENTIFIER clk) -> Pos clk
| INTEGER_NUMBER n -> (try Intgr (int_of_string n) with err -> Number n)
| IDENTIFIER id -> Id id
| TUPLE3 (IDENTIFIER id, EMPTY_TOKEN, EMPTY_TOKEN) -> Id id
| TUPLE7 (EMPTY_TOKEN, IDENTIFIER id1, DOT, IDENTIFIER id2, IDENTIFIER id3, EMPTY_TOKEN, EMPTY_TOKEN) ->
  Dot3(id1,id2,id3)
| TUPLE3 (IDENTIFIER id, DOT, IDENTIFIER member) -> Field (id, member)
| TUPLE4 (IDENTIFIER id, LBRACK, exp, RBRACK) -> Sel (id, rw' exp)
| TUPLE6 (IDENTIFIER id, LBRACK, lft, COLON, rght, RBRACK) -> Slice (id, rw' lft, rw' rght)
| TUPLE5 (IDENTIFIER lhs, LT_EQ, EMPTY_TOKEN, exp, SEMICOLON) -> NonBlock (lhs, rw' exp)
| TUPLE3 (lhs, PLUS, rhs) -> Add(rw' lhs, rw' rhs)
| TUPLE3 (lhs, HYPHEN, rhs) -> Sub(rw' lhs, rw' rhs)
| TUPLE3 (lhs, AMPERSAND, rhs) -> And(rw' lhs, rw' rhs)
| TUPLE3 (lhs, CARET, rhs) -> Xor(rw' lhs, rw' rhs)
| TUPLE3 (LPAREN, exp, RPAREN) -> rw' exp
| TUPLE6 (LBRACE, IDENTIFIER id, LBRACE, TLIST lst, RBRACE, RBRACE) -> Repl(id, List.rev_map rw' lst)
| TUPLE8 (EMPTY_TOKEN, If, LPAREN, cond, RPAREN, if_clause, Else, else_clause) ->
 Ifelse(rw' cond, rw' if_clause, rw' else_clause)
| TUPLE2 (Always, TUPLE2 (TUPLE4 (AT, LPAREN, sentry, RPAREN), stmts)) ->
 Sentry(rw' sentry, rw' stmts)
| TUPLE3 (lhs, EQUALS, exp) -> Block (rw' lhs, rw' exp)
| TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN,
      TLIST asgnlst,
      SEMICOLON) -> Asgnlst (List.rev_map rw' (asgnlst))
| TUPLE5 (LBRACK, hi, COLON, lo, RBRACK) -> Dim(rw' hi, rw' lo)
| TUPLE3 (TUPLE3 (Reg, EMPTY_TOKEN, TLIST dimlst),
      TLIST idlst,
      SEMICOLON) -> DeclReg(List.rev_map rw' (dimlst),List.rev_map (function
       | TUPLE3 (IDENTIFIER id, EMPTY_TOKEN, EMPTY_TOKEN) -> id
       | oth -> missing := Some oth; failwith "rw'") (idlst))
| TUPLE5 (Output, TUPLE3 (Reg, EMPTY_TOKEN, TLIST dimlst),
      IDENTIFIER id, EMPTY_TOKEN, EMPTY_TOKEN) -> DeclReg (List.rev_map rw' (dimlst), [id])
| TUPLE4 (Begin, TLIST stmts, End, EMPTY_TOKEN) ->
 BeginBlock (match List.rev_map rw' (stmts) with Itmlst x :: [] -> x | oth -> oth)
| TLIST lst -> Itmlst(List.rev_map rw' lst)
| TUPLE5 (lhs, EMPTY_TOKEN, EMPTY_TOKEN, EQUALS, exp) -> Block (rw' lhs, rw' exp)
| TUPLE3 (TUPLE3 (Bit, EMPTY_TOKEN, EMPTY_TOKEN), TLIST lst, SEMICOLON) ->
   Bitlst(List.rev_map rw' lst)
| TUPLE3 (TUPLE2 (Int, EMPTY_TOKEN), TLIST lst, SEMICOLON) -> DeclInt (List.rev_map (function
  | TUPLE3 (IDENTIFIER id, EMPTY_TOKEN, EMPTY_TOKEN) -> id
  | oth -> failwith "Int") lst)
| TUPLE5 (DOT, IDENTIFIER port, LPAREN, conn, RPAREN) -> Dot(port,rw' conn)
| TUPLE5 (IDENTIFIER id, EMPTY_TOKEN, LPAREN, TLIST [TLIST lst], RPAREN) ->
  DeclIntf2 (id, List.rev_map rw' lst)
| TUPLE4 (IDENTIFIER id, EMPTY_TOKEN, TLIST lst, SEMICOLON) -> DeclIntf1 (id, List.rev_map rw' lst)
| TUPLE5 (IDENTIFIER id, EMPTY_TOKEN, LPAREN, TLIST lst, RPAREN) -> Parenth (id, List.rev_map rw' lst)
| TUPLE4 (IDENTIFIER id, TUPLE4 (HASH, LPAREN, TLIST lst, RPAREN), TLIST lst', SEMICOLON) ->
  Hash(id, List.rev_map rw' lst, List.rev_map rw' lst')
| TUPLE2 (TUPLE2 (Parameter, TUPLE2 (Int, Unsigned)),
            TUPLE4 (IDENTIFIER id, EMPTY_TOKEN, EMPTY_TOKEN,
              TUPLE2 (EQUALS, exp))) -> Param(id, rw' exp)
| TUPLE4 (IDENTIFIER id, LPAREN, TLIST lst, RPAREN) -> Parenth (id, List.rev_map rw' lst)
| TUPLE3 (Modport, TLIST lst, SEMICOLON) -> DeclModPort(List.rev_map rw' lst)
| TUPLE3 (TUPLE3 (Logic, EMPTY_TOKEN, EMPTY_TOKEN), TLIST lst, SEMICOLON) -> DeclLogic(List.rev_map rw' lst)
| TUPLE3 (LBRACE, TLIST lst, RBRACE) -> Concat (List.rev_map rw' lst)
| TUPLE7
     (TUPLE3 (Interface, EMPTY_TOKEN, IDENTIFIER id),
      TUPLE4 (HASH, LPAREN, TLIST lst, RPAREN),
      TUPLE3 (LPAREN, TLIST lst', RPAREN),
      SEMICOLON, TLIST lst'', Endinterface, EMPTY_TOKEN) ->
  DeclIntf(id, List.rev_map rw' lst, List.rev_map rw' lst', List.rev_map rw' lst'')
| TUPLE3 (TUPLE3 (Logic, EMPTY_TOKEN, TLIST lst), TLIST lst', SEMICOLON) ->
  Logic(List.rev_map rw' lst, List.rev_map rw' lst')
| oth -> missing := Some oth; failwith "rw'"

let p' = rw p;;
let x = rw' p';;
