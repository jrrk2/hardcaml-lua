(**************************************************************************)
(*                                                                        *)
(* OCaml template Copyright (C) 2004-2010                                 *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(* Adapted to boolean logic by Jonathan Kimmitt                           *)
(*  Copyright 2016 University of Cambridge                                *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*
#use ".ocamlinit.output"
*)

(*
#use ".ocamlinit.lef"
*)

(*
#use ".ocamlinit.program"
*)

(*
#use ".ocamlinit.ansic"
*)

(*
open Output
open Template
open Output_parser

let _ = parse "V3ParseBison.output";;
let (t,g) = List.hd !tg';;
let mungelst = ref [];;
Hashtbl.iter (fun k x -> mungelst := (k,x) :: !mungelst) mungeh;;
let fd = open_out "mungelst.ml" in
List.iter ( fun (k,x) ->
	  Printf.fprintf fd "    %s, \"%s\";\n" k x
	  ) (List.sort compare !mungelst);
close_out fd
;;
*)

open Source_text_rewrite_types
open Source_text_rewrite
open Source_text_lex
open Source_text
open Dump_vhdl

let v = "timer.v";;
let v = "interface_test.sv";;
let v = "wrapper.sv";;
let v = "loop.v";;
let v = "picorv32_ref.v";;
let v = "process.v";;
let v = "preprocess.sv";;
let v = "blocking.v";;
let v = "prec.sv";;
let v = "uart.sv";;
   
let modlst,x,p,p' = rewrite v;;

(*
let _ = Hashtbl.iter (fun k x -> let fd = open_out (k^".dump") in dump fd x; close_out fd) modules;;
*)

let y = unroll {subst=Hashtbl.create 255; fn=descend} x;;

let z = Hashtbl.find modules "apb_uart";;
let Modul(entnam, port_lst, body_lst) = z;;
let s = List.filter (function Sentry _ -> false | DeclReg _ -> false | Asgnlst [Blocking (Id _, _)] -> true | _ -> false) body_lst;;
let a x = List.nth s x;;

let b = List.filter (function DeclReg _ -> false | Asgnlst _ -> true | Sentry _ -> false | _ -> false) body_lst;;

let rwmods = Hashtbl.create 255;;

let scanp = 
  List.iter (function
    | TUPLE7 (TUPLE3 (Module, EMPTY_TOKEN, IDENTIFIER nam), arg1, arg2, arg3, arg4, arg5, arg6) -> Hashtbl.add rwmods nam (arg1, arg2, arg3, arg4, arg5, arg6)
    | _ -> ())

let _ = match p' with
    | TUPLE2(TLIST lst, _) -> scanp lst
    | _ -> ();;

let conthash = Hashtbl.create 255;;
let othasgn = ref None

let (arg1, arg2, arg3, arg4, arg5, arg6) = Hashtbl.find rwmods "apb_uart";;
let TLIST lst = arg4;;
let lst' = List.filter (function TUPLE5 (Assign, _, _, _, _) -> true | _ -> false) lst;;
let _ = List.iter (function
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (IDENTIFIER lhs, EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (TUPLE6 (IDENTIFIER lhs, LBRACK, hi, COLON, lo, RBRACK), EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | TUPLE5 (Assign, EMPTY_TOKEN, EMPTY_TOKEN, TLIST [TUPLE3 (TUPLE4 (IDENTIFIER lhs, LBRACK, ix, RBRACK), EQUALS, expr)], SEMICOLON) -> Hashtbl.replace conthash lhs expr
  | oth -> othasgn := Some oth; failwith "Assign") lst';;

let v' = List.filter (function
 | (Source_text_rewrite_types.Add _, _, _) -> false
 | ((Sub _ |Id _|Number _ | Intgr _ | Slice _ | Sel _ | Equals _ | GtEq _ | Expression (Equals _) | Expression (Or (Equals _ , Equals _))), _, _) -> false
 | (And2 _, _, _) -> true
 | _ ->false) !vlst;;
