(**************************************************************************)
(*                                                                        *)
(* OCaml template Copyright (C) 2004-2010                                 *)
(*  Sylvain Conchon, Jean-Christophe Filliatre and Julien Signoles        *)
(* Adapted to boolean logic by Jonathan Kimmitt                           *)
(*  Copyright 2016 University of Cambridge                                *)
(*                                                                        *)
(*  This software is free software; you can redistribute it and/or        *)
(*  modify it under the terms of the GNU Library General Public           *)
(*  License version 2.1, with the special exception on linking            *)
(*  described in file LICENSE.                                            *)
(*                                                                        *)
(*  This software is distributed in the hope that it will be useful,      *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                  *)
(*                                                                        *)
(**************************************************************************)

(*
#use ".ocamlinit.output"
*)

(*
#use ".ocamlinit.lef"
*)

(*
#use ".ocamlinit.program"
*)

(*
#use ".ocamlinit.ansic"
*)

(*
open Output
open Template
open Output_parser
let _ = parse "V3ParseBison.output";;
let (t,g) = List.hd !tg';;
let mungelst = ref [];;
Hashtbl.iter (fun k x -> mungelst := (k,x) :: !mungelst) mungeh;;
let fd = open_out "mungelst.ml" in
List.iter ( fun (k,x) ->
	  Printf.fprintf fd "    %s, \"%s\";\n" k x
	  ) (List.sort compare !mungelst);
close_out fd
;;
*)

open Source_text_rewrite_types
open Source_text_rewrite
open Source_text_lex
open Source_text

let v = "timer.v";;
let v = "process.v";;
let v = "interface_test.sv";;
let v = "picorv32_ref.v";;
let v = "loop.v";;
let v = "wrapper.sv";;
let v = "preprocess.sv";;
   
let modlst,x = rewrite v;;
let loop = Hashtbl.find modules (List.hd modlst);;

type attr = {subst: (string,rw)Hashtbl.t}

let rec descend (attr:attr) = function
  | Itmlst(rw_lst) -> Itmlst(descend_lst attr (rw_lst:rw list))
  | Sentry (Pos clk, lst) -> Sentry(Pos clk, descend attr lst)
  | Unknown str -> Unknown str
  | In -> In
  | Out -> Out
  | Modul(str1, rw_lst2, rw_lst3) -> Modul(str1, descend_lst attr rw_lst2, descend_lst attr rw_lst3)
  | Id id -> (match Hashtbl.find_opt attr.subst id with None -> Id id | Some exp -> exp)
  | DeclReg(rw_lst, str1_lst, rw_lst_lst) -> DeclReg(descend_lst attr rw_lst, str1_lst,
    List.map (fun itm -> descend_lst attr itm) rw_lst_lst)
  | NonBlocking(rw, rw2) -> NonBlocking(descend attr rw, descend attr rw2)
  | Query(rw, rw2, rw3) -> Query(descend attr rw, descend attr rw2, descend attr rw3)
  | Port(rw, str1, rw_lst) -> Port(descend attr rw, str1, descend_lst attr rw_lst)
  | Pos(str1) -> Pos (str1)
  | Neg(str1) -> Neg (str1)
  | Edge(rw, rw2) -> Edge(descend attr (rw), descend attr (rw2))
  | Intgr(int1) -> Intgr int1
  | Number(str1) -> Number (str1)
  | Sel(str1, rw2) -> Sel(str1, descend attr rw2)
  | Inc(rw) -> Inc(descend attr rw)
  | Dec(rw) -> Dec(descend attr rw)
  | RedAnd(rw) -> RedAnd(descend attr (rw))
  | RedOr(rw) -> RedOr(descend attr (rw))
  | UMinus(rw) -> UMinus(descend attr (rw))
  | Pling(rw) -> Pling(descend attr (rw))
  | Tilde(rw) -> Tilde(descend attr (rw))
  | Equals(rw, rw2) -> Equals(descend attr (rw), descend attr (rw2))
  | NotEq(rw, rw2) -> NotEq(descend attr (rw), descend attr (rw2))
  | LtEq(rw, rw2) -> LtEq(descend attr (rw), descend attr (rw2))
  | GtEq(rw, rw2) -> GtEq(descend attr (rw), descend attr (rw2))
  | Less(rw, rw2) -> Less(descend attr (rw), descend attr (rw2))
  | And(rw, rw2) -> And(descend attr (rw), descend attr (rw2))
  | And2(rw, rw2) -> And2(descend attr (rw), descend attr (rw2))
  | Or(rw, rw2) -> Or(descend attr (rw), descend attr (rw2))
  | Or2(rw, rw2) -> Or2(descend attr (rw), descend attr (rw2))
  | Xor(rw, rw2) -> Xor(descend attr (rw), descend attr (rw2))
  | Shiftl(rw, rw2) -> Shiftl(descend attr (rw), descend attr (rw2))
  | Shiftr(rw, rw2) -> Shiftr(descend attr (rw), descend attr (rw2))
  | Shiftr3(rw, rw2) -> Shiftr3(descend attr (rw), descend attr (rw2))
  | Add(rw, rw2) -> Add(descend attr (rw), descend attr (rw2))
  | Sub(rw, rw2) -> Sub(descend attr (rw), descend attr (rw2))
  | Mult(rw, rw2) -> Mult(descend attr (rw), descend attr (rw2))
  | Div(rw, rw2) -> Div(descend attr (rw), descend attr (rw2))
  | Ifelse(rw, rw2, rw3) -> Ifelse(descend attr (rw), descend attr (rw2), descend attr (rw3))
  | Iff(rw, rw2) -> Iff(descend attr (rw), descend attr (rw2))
  | ForLoop(rw_lst, rw2, rw3, rw4) ->
    ForLoop(descend_lst attr (rw_lst), descend attr (rw2), descend attr (rw3), descend attr (rw4))
  | CaseStmt(rw, rw_lst) -> CaseStmt(descend attr (rw), descend_lst attr (rw_lst))
  | CaseItm(rw_lst) -> CaseItm(descend_lst attr (rw_lst))
  | AlwaysComb(rw_lst) -> AlwaysComb(descend_lst attr (rw_lst))
  | Sentry(rw, rw2) -> Sentry(descend attr (rw), descend attr (rw2))
  | Blocking(rw, rw2) -> Blocking(descend attr (rw), descend attr (rw2))
  | Asgnlst(rw_lst) -> Asgnlst(descend_lst attr (rw_lst))
  | DeclInt(str1_lst) -> DeclInt((str1_lst))
  | Dim(rw, rw2) -> Dim(descend attr (rw), descend attr (rw2))
  | BeginBlock(rw_lst) -> BeginBlock(descend_lst attr (rw_lst))
  | Bitlst(rw_lst) -> Bitlst(descend_lst attr (rw_lst))
  | Dot(str1, rw2) -> Dot(str1, descend attr (rw2))
  | Unsigned(rw) -> Unsigned(descend attr (rw))
  | Signed(rw) -> Signed(descend attr (rw))
  | Concat(rw_lst) -> Concat(descend_lst attr (rw_lst))
  | DeclWire(rw_lst, rw_lst2) -> DeclWire(descend_lst attr (rw_lst), descend_lst attr (rw_lst2))
  | WireExpr(str1, rw2) -> WireExpr(str1, descend attr (rw2))
  | DeclIntf1(str1, rw_lst) -> DeclIntf1(str1, descend_lst attr (rw_lst))
  | DeclIntf2(str1, rw_lst) -> DeclIntf2(str1, descend_lst attr (rw_lst))
  | Hash(str1, rw_lst, rw_lst2) -> Hash(str1, descend_lst attr (rw_lst), descend_lst attr (rw_lst2))
  | DeclIntf(str1, rw_lst, rw_lst2, rw_lst3) -> DeclIntf(str1, descend_lst attr (rw_lst), descend_lst attr (rw_lst2), descend_lst attr (rw_lst3))
  | DeclModPort(rw_lst) -> DeclModPort(descend_lst attr (rw_lst))
  | Repl(rw, rw_lst) -> Repl(descend attr (rw), descend_lst attr (rw_lst))
  | Slice(str1, rw2, rw3) -> Slice(str1, descend attr (rw2), descend attr (rw3))
  | Field(rw, rw2) -> Field(descend attr (rw), descend attr (rw2))
  | Dot3(str1, str2, str3) -> Dot3(str1, str2, str3)
  | Parenth(str1, rw_lst) -> Parenth(str1, descend_lst attr (rw_lst))
  | Logic(rw_lst, rw_lst2) -> Logic(descend_lst attr (rw_lst), descend_lst attr (rw_lst2))
  | Param(str1, rw2) -> Param(str1, descend attr (rw2))
  | LocalP(rw_lst, rw_lst2) -> LocalP(descend_lst attr (rw_lst), descend_lst attr (rw_lst2))
  | DeclLogic(rw_lst) -> DeclLogic(descend_lst attr (rw_lst))
  | DeclTask(str1, rw_lst2, rw3, rw4) -> DeclTask(str1, descend_lst attr (rw_lst2), descend attr (rw3), descend attr (rw4))
  | Mem1(str1, rw_lst) -> Mem1(str1, descend_lst attr (rw_lst))
  | Mem3(str1, rw2, rw3, rw4) -> Mem3(str1, descend attr (rw2), descend attr (rw3), descend attr (rw4))
  | PartSel(str1, rw2, rw3) -> PartSel(str1, descend attr (rw2), descend attr (rw3))
  | GenBlock(rw_lst) -> GenBlock(descend_lst attr (rw_lst))

and descend_lst attr x = List.map (descend attr) x

let h=Hashtbl.create 255;;
Hashtbl.add h "i" (Intgr 0);;
let y = descend {subst=h} x;;
